# Java面试题

## 一. Java 基础

#### 1.1 为什么重载hashCode 和 equals方法？(HashMap的key为对象类型,需要哪些处理?)

#### 1.2 String、StringBuffer与StringBuilder的区别?

#### 1.3 Java的异常结构树?

#### 1.4 Override和Overload的含义与区别?



## 二. Java 集合

#### 2.1 各种集合的种类、区别 和 优缺点？



## 三. Java 并发

#### 3.1 什么情况下要使用到多线程?

> 多线程出现的原因是，为了充分利用多核CPU的优势，提高CPU的利用效率，同时处理多个任务；
>
> 第一种：高并发。当系统处于高并发的环境中，这个时候需要使用多线程来处理大量的用户请求；
>
> 第二种：大任务。例如大文件上传，采用多线程分片上传文件，可以加快文件的上传，避免长时间的等待；
>
> 第三种：复杂任务。如果后台出现一些特别耗时的任务（文件I/O，网络I/O等），可以采用多线程异步处理；

#### 3.2 使用多线程优缺点?

> 【优点】使用多线程最直接的优点是可以提高系统的处理速度，充分利用计算机资源。
>
> 【缺点】使用多线程的缺点有：
>
>  1. 由于多线程执行顺序的随机性，导致程序运行复杂度提升，可能会因为考虑不周导致程序bug或死锁。
>  2. 系统在进行线程切换时会消耗一部分性能
>  3. 程序开发复杂度提升

#### 3.3 如何理解线程安全与线程不安全(为什么会出现线程不安全)? 如何避免线程不安全?

> 对于相同的代码，在线程条件下执行，每一次的执行结果总是一样的，那么就可以认为这个代码使线程安全的，反之，则是线程不安全的。
>
> 

#### 3.1 线程和进程的区别?

#### 3.2 Java中实现线程的三种方式?

#### 3.3 线程的几种状态?

#### 3.4 如何理解线程安全与线程不安全(为什么会出现线程不安全)? 如何避免线程不安全?

#### 3.5 Java中的volatile 变量是什么？volitile关键字的作用,原理?

Volatile 是Java的关键字，是Java提供的最轻量级的同步机制。

变量使用volatile修饰后两个作用：

- 保证此变量对所有线程的可见性
- 禁止指令重排优化

注：volatile只能保证可见性，不能保证原子性，只符合以下两种场景

- 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程会修改变量的值。
- 变量不需要与其他状态变量共同参与不变约束。



为了提高处理器的执行速度，在处理器和内存之间增加了多级缓存来提升。但是由于引入了多级缓存，就存在缓存数据不一致问题。

但是，对于volatile变量，当对volatile变量进行写操作的时候，JVM会向处理器发送一条lock前缀的指令，将这个缓存中的变量回写到系统主存中。

但是就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题，所以在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议

缓存一致性协议：每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。

所以，如果一个变量被volatile所修饰的话，在每次数据变化之后，其值都会被强制刷入主存。而其他处理器的缓存由于遵守了缓存一致性协议，也会把这个变量的值从主存加载到自己的缓存中。这就保证了一个volatile在并发编程中，其值在多个缓存中是可见的





#### 3.6 sychronized 修饰静态方法和成员方法的区别是什么?

#### 3.7 HashMap是线程安全的么？HashTable呢？ConcurrentHashMap有什么了解？

#### 3.8 sychronized 与 lock 的区别?

#### 3.9 Java中如何停止一个线程？

#### 3.10 Java多线程中的死锁?如何避免?

#### 3.11 Java线程池的作用? 线程池的几个核心参数, 之间的关系是怎样的?

我们先来看看线程池带来了哪些好处。

1. 降低资源的消耗。线程本身是一种资源，创建和销毁线程会有CPU开销；创建的线程也会占用一定的内存。
2. 提高任务执行的响应速度。任务执行时，可以不必等到线程创建完之后再执行。
3. 提高线程的可管理性。线程不能无限制地创建，需要进行统一的分配、调优和监控。

接下来，我们看看不使用线程池有哪些坏处。

1. 频繁的线程创建和销毁会占用更多的CPU和内存
2. 频繁的线程创建和销毁会对GC产生比较大的压力
3. 线程太多，线程切换带来的开销将不可忽视
4. 线程太少，多核CPU得不到充分利用，是一种浪费

因此，我们有必要对线程池进行比较完整地说明，以便能对线程池进行正确地治理。



线程池，本质上是一种对象池，用于管理线程资源。
在任务执行前，需要从线程池中拿出线程来执行。
在任务执行完成之后，需要把线程放回线程池。
通过线程的这种反复利用机制，可以有效地避免直接创建线程所带来的坏处



我们的关注点在于，任务提交之后是怎么执行的。大致如下：

1. 判断核心线程池是否已满，如果不是，则创建线程执行任务
2. 如果核心线程池满了，判断队列是否满了，如果队列没满，将任务放在队列中
3. 如果队列满了，则判断线程池是否已满，如果没满，创建线程执行任务
4. 如果线程池也满了，则按照拒绝策略对任务进行处理

corePoolSize -> 任务队列 -> maximumPoolSize -> 拒绝策略



#### 3.12 介绍Java中的单例模式?如何设计一个线程安全的单例模式?



#### 3.13 分布式锁介绍

​	分布式锁的作用： 

​		多个服务对同一个资源同步访问的时候，需要分布式锁协调调度。

​	分布式锁的特点：

	- 高可用的获得锁和释放锁
	- 高性能的获得锁和释放锁

​	分布式锁的三种实现方式

- 数据库实现

  利用数据库的行锁

  原理： 不同线程并发更新同一条记录，更新成功表示获取到锁。

  缺点： 不能重入；使用麻烦，不能重复尝试获取锁；锁释放不安全；

- Zookeeper实现

  利用ZK的临时顺序节点特性。

  原理： 获取锁时，向特定节点注册临时顺序节点，获取该节点下所有的节点数据，判断自己是否是最小节点，如果是，则获取到锁；否则，注册上一个最小节点的监听后，wait()。

- Redis实现

  利用SETNX命令（KEY不存在的时候才能设置成功），并设置一定的超时时间。

  



## 四. Java IO



## 五. 数据库


#### 5.1 数据库底层的了解？
#### 5.2 什么是聚簇索引和非聚簇索引？

​	数据库中，B+树索引分为聚簇索引和非聚簇索引。两者内部都是B+树的，都是高度平衡，即叶子节点存储全部数据。两者唯一不同的是，叶子节点存储的是否是一整行数据的信息。

​	聚簇索引，叶子节点存储的是一整行数据的信息。对于排序查找和范围查找的速度非常快。

​	非聚簇索引，又叫辅助索引。叶子节点的存储的是指向真实数据的索引地址。

​	一张表，可以有多个辅助索引，只能有一个聚簇索引。

#### 5.3 索引底层原理是什么？

​	搜索树

#### 5.4 B+树跟B树有什么区别？

​	B+树的内节点不存储数据，只有索引，因此可以存储更多的索引节点，降低树的高度。叶子节点存储数据。

#### 5.5 Hash索引？

​	Hash索引的底层是哈希表（Hash Table），该索引由数据库自动创建，支持等值查询。

#### 5.6 索引的最左前缀原理？

​	对于联合索引需要遵循最左前缀原则，如 index:（a,b,c）,会创建3个索引，a, ab, abc。

#### 5.7 MySQL数据库的事务隔离级别？

​	默认隔离级别是可重复读。

 - 读未提交

   可以查看到其他事务未提交的数据，会产生脏读

 - 读已提交

   其他事务已提交的数据才能查看到。该级别也常称为不可重复读，因为在同一事务之内，多次查询可能看到的数据不一样

 - 可重复读

	该级别可以解决同一事务内，多次查询看到不相同的数据。但是，该级别会产生幻读。例如：A事务在批量修改某一个字段的时候，这个时候另一个事务B，又新插入了一条记录，并提交。这个时候当A事务提交事务之后，再次查询发现有一条记录的值没有被更改，这个时候就好像事务没有成功执行一样，产生"幻读"
	
- 串行化

  最严格的事务控制，所有的事务按序提交，可以解决幻读问题。

#### 5.8 Mysql的log有哪些，分别用来解决什么问题？

​	MySQL中有六种日志文件，分别是：

​	重做日志（redo log） 回滚日志（undo log） 二进制日志（binlog） 错误日志（errorlog） 慢查询日志（slow query log） 一般查询日志（general log） 中继日志（relay log）。

- redo log

  确保事务的持久性。redo日志记录事务执行后的状态，用来恢复未写入data file的已成功事务更新的数据。防止在发生故障的时间点，尚有脏页未写入磁盘，在重启MySQL服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性。

- binlog

  用于复制，在主从复制中，从库利用主库上的binlog进行重播，实现主从同步

- slow query log

#### 5.9 MySQL的执行计划EXPLAIN ？

​	通过执行EXPLAIN ，可以判断是否走索引。

​	type：索引类型； key：使用的索引；

## 六. Web框架

## 七. 网络

#### 7.1 NIO | BIO | AIO 的区别？

#### 7.2  介绍HTTP的无状态特性？ 解决无状态的方式？ session与cookie？



## 八. JVM相关

## 九. 中间件

### 9.1 Redis缓存

### 9.2 消息队列

> 使用消息队列最核心的优点是：解耦、异步和消峰



常用的四种MQ**

- ActiveMQ
- RabbitMQ
- RocketMQ
- Kafka



##### 9.2.1 如何保证消息队列的高可用？

​	主从集群架构、分布式集群架构

##### 9.2.2 如何保证消息不被重复消费？

​	因为网络传输等等故障，确认信息没有传送到消息队列，导致消息队列不知道自己已经消费过该消息了，再次将该消息分发给其他的消费者。

针对业务场景具体分析

##### 9.2.3 如何保证消费的可靠性传输（数据不丢失）?

​	每种MQ都要从三个角度来分析:生产者弄丢数据、消息队列弄丢数据、消费者弄丢数据

- **生产者弄丢数据**

  消息确认机制

- **消息队列弄丢数据**

  一般是开启持久化磁盘的配置

- **消费者弄丢数据**

  手动确认消息



##### 9.2.4 如何保证消息的顺序性？

​	通过某种算法，将需要保持先后顺序的消息放到同一个消息队列中，只用一个消费者去消费该队列。



### 9.3 Zookeeper

## 十. 数据结构

## 十一. 算法

### 十二. 架构

#### 12.1 怎么解决高并发？

> 高并发的解决方向一般分为四种：
>
> 1. WEB端（一般指前端）
>
>    a. 减少HTTP的请求。主要的策略是合并CSS、JavaScript、图片等静态资源。
>
>    b. 使用动静分离。将项目中的静态资源和后台服务分开部署。静态资源使用CDN缓存。
>
>    c. 资源压缩、开启浏览器缓存等
>
> 2. 服务端优化
>
>    a. 使用分布式缓存服务。将系统热点数据缓存在redis中。特指，读写比很高，很少变化的数据
>
>    b. 异步化。这里主要是使用各种消息中间件，将无需同步操做的任务异步处理，请求消峰。
>
>    c. 集群化。使用负载均衡、反向代理服务器将请求分发到集群服务中。
>
>    d. 数据库集群化、读写分离
>
>    e. 代码优化。SQL优化，IO优化，JVM优化等
>
> 3. 硬件优化
>
>    a. 使用更好的存储设备、更大的内存、多核CPU等。





